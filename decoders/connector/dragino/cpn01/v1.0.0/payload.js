/*
 * TagoIO Decoders - (https://tago.io/)
 * -------------------
 * Generated by     :: tagoio
 * Generated at     :: Thu Oct 12 2023 13:58:04 GMT+0000 (Coordinated Universal Time)
 * Machine          :: fred <linux> - Node.js v20.6.0
 * -------------------
*/

function datalog(hexStringAfter28) {
    const x = hexStringAfter28.length / 22;
    const len = hexStringAfter28.length / x;
    let string = "";
    for(let i = 0; i < x; i++){
        const start = i * len;
        const end = (i + 1) * len;
        const slice = hexStringAfter28.slice(start, end);
        const aa = parseInt(slice.slice(0, 2), 16);
        const bb = parseInt(slice.slice(2, 8), 16);
        const cc = parseInt(slice.slice(8, 14), 16);
        const dd = getMyDate(parseInt(slice.slice(14, 22), 16));
        const ee = `[${aa},${bb},${cc},${dd}],`;
        string += ee;
    }
    return string;
}
function getzf(c_num) {
    if (parseInt(c_num) < 10) {
        c_num = 0 + Number(c_num);
    }
    return c_num;
}
function getMyDate(str) {
    let c_Date;
    if (str > 9999999999) {
        c_Date = new Date(parseInt(str));
    } else {
        c_Date = new Date(parseInt(str) * 1000);
    }
    const c_Year = c_Date.getFullYear(), c_Month = Number(c_Date.getMonth()) + 1, c_Day = c_Date.getDate(), c_Hour = c_Date.getHours(), c_Min = c_Date.getMinutes(), c_Sen = c_Date.getSeconds();
    const c_Time = `${c_Year}-${getzf(c_Month)}-${getzf(c_Day)} ${getzf(c_Hour)}:${getzf(c_Min)}:${getzf(c_Sen)}`;
    return c_Time;
}
function decoderrr(buffer, bufA1, hexStringAfter28, data1, data2) {
    switch(buffer.length){
        case 27:
            {
                const data = [
                    {
                        variable: "version",
                        value: buffer.readInt16BE(8) / 100
                    },
                    {
                        variable: "device_id",
                        value: bufA1
                    },
                    {
                        variable: "bat",
                        value: buffer.readUInt16BE(10) / 1000,
                        unit: "v"
                    },
                    {
                        variable: "signal",
                        value: buffer.readInt8(12)
                    },
                    {
                        variable: "mod",
                        value: buffer.readInt8(13)
                    },
                    {
                        variable: "calculate_flag",
                        value: buffer.readInt8(14)
                    },
                    {
                        variable: "contact_status",
                        value: buffer.readUInt16BE(15)
                    },
                    {
                        variable: "alarm",
                        value: buffer.readUInt16BE(16)
                    },
                    {
                        variable: "total_pulse",
                        value: data1
                    },
                    {
                        variable: "the_last_open_duration",
                        value: data2
                    },
                    {
                        variable: "time_stamp",
                        value: getMyDate(buffer.readUInt32BE(23))
                    },
                    {
                        variable: "length",
                        value: buffer.length
                    }
                ];
                return data;
            }
        default:
            {
                const da = datalog(hexStringAfter28);
                const data3 = [
                    {
                        variable: "version",
                        value: buffer.readInt16BE(8) / 100
                    },
                    {
                        variable: "device_id",
                        value: bufA1
                    },
                    {
                        variable: "bat",
                        value: buffer.readUInt16BE(10) / 1000,
                        unit: "v"
                    },
                    {
                        variable: "signal",
                        value: buffer.readInt8(12)
                    },
                    {
                        variable: "mod",
                        value: buffer.readInt8(13)
                    },
                    {
                        variable: "calculate_flag",
                        value: buffer.readInt8(14)
                    },
                    {
                        variable: "contact_status",
                        value: buffer.readUInt16BE(15)
                    },
                    {
                        variable: "alarm",
                        value: buffer.readUInt16BE(16)
                    },
                    {
                        variable: "total_pulse",
                        value: data1
                    },
                    {
                        variable: "the_last_open_duration",
                        value: data2
                    },
                    {
                        variable: "time_stamp",
                        value: getMyDate(buffer.readUInt32BE(23))
                    },
                    {
                        variable: "length",
                        value: buffer.length
                    },
                    {
                        variable: "datalog",
                        value: da
                    }
                ];
                return data3;
            }
    }
}
// Search the payload variable in the payload global variable. It's contents is always [ { variable, value...}, {variable, value...} ...]
const payload_rawCnp1 = payload.find((x)=>x.variable === "payload_raw" || x.variable === "payload" || x.variable === "data");
if (payload_rawCnp1) {
    try {
        // Convert the data from Hex to Javascript Buffer.
        const buffer = Buffer.from(payload_rawCnp1.value, "hex");
        const Device_id = buffer.slice(0, 8);
        const bufA1 = Device_id.toString("hex");
        const hexString = buffer.toString("hex");
        const hexStringAfter28 = hexString.slice(54); // More information about buffers can be found here: https://nodejs.org/api/buffer.html
        const data1 = parseInt(hexString.slice(34, 40), 16);
        const data2 = parseInt(hexString.slice(40, 46), 16);
        const data = decoderrr(buffer, bufA1, hexStringAfter28, data1, data2);
        const group = String(Date.now());
        payload.forEach((obj)=>{
            obj.group = group;
        });
        // This will concat the content sent by your device with the content generated in this payload parser. // It also add the field "group" and "time" to it, copying from your sensor data.
        payload = payload.concat(data.map((x)=>({
                ...x,
                group: String(payload_rawCnp1.serie || payload_rawCnp1.group)
            })));
    } catch (error) {
        // Print the error to the Live Inspector.
        console.error(error); // Return the variable parse_error for debugging.
        payload = [
            {
                variable: "parse_error",
                value: error.message
            }
        ];
    }
}


//#sourceMappingURL=data:application/json;charset=utf-8;base64,IntcInZlcnNpb25cIjozLFwic291cmNlc1wiOltdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCJcIixcImZpbGVcIjpcInN0ZG91dFwifSI=